# Introduction and Background

NENA needs a stable place to put the artifacts generated as part of the standards development process that are used by software developers to implement the standard which are tools, rather than the text of the standard itself. The most common artifact is a schema or interface description (YAML file), but there are others. The development process for these artifacts is different that the editing process of a standard. The tools used to create and maintain them is different. This document describes how NENA uses the GitHub tool to maintain these artifacts.

NENA’s repositories are held at [https://github.com/NENA911](https://github.com/NENA911). 

# Repositories

A repository ("repo") in githib is a folder (directory) of files. The artifact itself is a file, but there may be other files such as shell scripts, documents, test cases, other folders, etc. Each file has a revision history which is tracked by Github. Github commonly has a repository per “project”. In NENA, an API is a project, as opposed to, say, a document. This is because documents may modify any number of APIs, some of which may have been defined in different documents. NENA repositories are not limited to APIs, and a repository may be created for other purposes.

A working group creating a new artifact requests the NENA GitHub administrator to create the repo.

## Versions

Artifacts have versions, which follow the pattern of NENA document versions: \<major>.\<minor>\<update>, where a minor versions of a major version are backwards compatible with each other.  The artifact is reviewed as part of a document review process and the merge to “main” only occurs on completion of that process. The \<update> designation is for updates to a version that used the “errata” process defined in NENA-ADM-001.   

The version of an artifact is NOT tied to the version of the document that creates or modifies it. The first version of an artifact is 1.0, regardless of the version of the document that creates it, and it increases versions as that document, or other documents, make changes to the artifact. If any document, regardless of whether it is a new document or a major or minor version of an existing document, updates an artifact in a way that is backwards compatible with all minor versions of the major version the artifact is currently, then the artifact gets the next minor version and retains the existing major version. As a change to an artifact that is not backwards compatible with other minor versions, by definition, makes the document a major version update, major version updates to artifacts are always major version updates to the document that makes the change.  A minor version update to a document could create a new artifact (1.0 version) as long as the artifact was optional to use.

## Branches

Repositories foster development of artifacts by allowing creation of a “branch”. A branch is effectively a copy of the repository to which changes may be made to any of the files, and specifically the artifacts, without affecting the (default) “main” branch that always represents the latest released version of the repository. Branches may be merged into other branches, including “main”.  When a branch is merged to “main”, that is the formal release of the version, and becomes the new release. Older branches are maintained essentially forever, so that users may download any branch.  This is the way versions are maintained: as branches in the repository. 

The name of a branch is the version the artifact will become when the document that releases it or updates it is approved. For example, suppose version 3 of a document created version 1.0 of an artifact. Later, version 3.2 of the document updates the artifact in a backwards compatible way. A branch named V1.1 will be created, updates will be made to that branch as development of the 3.2 version of the document proceeds. When the document is approved as version 3.2, the V1.1 branch will be merged into the “main” branch of the artifact. If another document needs to further modify the artifact, a new 1.3 branch will be created in the repository and changes in that branch will be accepted as the development of the other document proceeds.

The working group decides how it will manage its branch. Co-chairs may approve commits or a designated expert or experts may be appointed to manage the branch.

## Commits and Pushes

Users typically “clone” a repo, select a branch, and edit files in that branch.  The clone is maintained by git as a local copy of the entire repo.  When changes in files are made, the git system tracks the changes.  An operation called a “Commit” commits the changes in the repo. The commit memorializes what was changed, who changed it, and when it was changed.  A comment may be added to the commit.  For NENA documents, comments are always included that summarize the changes. It is possible in some systems to “push” the commit to the main repo, but NENA repos do not allow this.  See “Pull Requests” below.

## Pull Requests

Pull Requests are requests from an author to apply a set of changes to a branch.  Github manages this process with lots of automation.  The working group that owns the branch approves pull requests as changes are reviewed, similar to how documents are updated. Contrast this with a Push that directly changes the repo branch following a local commit. NENA repos exclusively use Pull requests and do not permit Push operations.  Pull requests are reviewed and then merged to the branch.

## Ownership

A NENA repository has an owner.  The owner is normally the work group that controls the API.  For a new API, the work group that created it is the owner. The work group remains the owner until the DSC changes the ownership.  Ownership changes should occur rarely, and usually are prompted by the current owner having stable documents that use the API while another work group is actively modifying the API.  The DSC should strive to have the work group with the most active contributors, but one which has the broadest possible scope be the owner, and should only change ownership if there is a good reason.  One good reason might be that the current owner frequently stymies proposed non-backwards compatible changes without significant technical reasons, which prevents another work group from getting their goals accomplished.

The owner has final say on the main branch.  This means that another working group making changes on a development branch must assure that the owner working group will approve its branch being merged following approval of its document.  When in doubt, an approval ballot may be requested by the development branch owner on the repository owner working group.  Approval of the ballot indicates consensus of the owner working group to release the version approved by the development working group.

Development branches are created and owned by the working group that is creating or changing the artifact.

## Tags

GitHub has the ability to tag specific points in a repository’s history as being important.  A tag is a short string attached to a specific commit.

NENA’s documents use tags to indicate review cycles and released versions.  Other uses of tags are up to the development or owner working group. When a document undergoes a review, per NENA-ADM-001, the version of the artifact that is being reviewed gets a tag that matches the review.  The tags are “working-group-review”, “all-committee-review” (or “all-committee-review-2” or -3, etc), and “public-review” (or “public-review-2” or -3, etc.).  When a document is approved for publication, and the branch is merged to main, merged version gets a tag with the version (such as “V1.2”).  This allows an implementor to know what the most current released version is: the tag on “main”.

## Issues

NENA makes good use of the issues feature of GitHub.  An issue may be a bug report, a feature request, a memory jogger or a strategic issue being worked by multiple contributors.  Any work group member may create an issue.  Issues are managed by work group co-chairs or co-chairs may delegate issue management to a skilled member or group of members of the work group. Work group members are encouraged to use issue templates, and work groups are encouraged to create templates for frequently occurring issue sources beyond the default bug report and feature request templates.   When creating or working issues, contributors are encouraged to use permalinks to link to artifacts or other files in a repo.  Crosslinking of issues, when they are related, is also encouraged. Larger issues should include a checklist to manage multiple aspects of one issue.  (possible advise on labels?  Do we want a set of standard labels?).  When creating pull requests that resolve issues, include the Issue as a cross link in the PR.

Some work groups use GitHub issues to manage issues that occur within the document development process, beyond the artifacts that are maintained in GitHub.  Similar to a “parking lot”, the issues mechanism mechanizes remembering, processing and documenting item the work group agreed “to do”. This does require non-developer working group members to learn how to use at least the issue management facilities of GitHub.
